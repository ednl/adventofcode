Prompted by /u/musifter 's [review of 2015 day 10](https://old.reddit.com/r/adventofcode/comments/1q8vjn0/2015_day_10_in_review_elves_look_elves_say/), I looked at my old solution for [Elves Look, Elves Say](https://adventofcode.com/2015/day/10) and realised I could massively improve the algorithm by using the "atomic elements" of the sequence as mentioned on the [Look-and-say Wikipedia page](https://en.wikipedia.org/wiki/Look-and-say_sequence#Cosmological_decay) (click 'show' to see the table with elements).

To recap: the puzzle asks you to apply the look-and-say rule repeatedly to your input, first 40 times and then 50 times. Look-and-say is like [run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding) where you go from left to right and replace every range of the same number with the count and the number. For example: `133` is replaced with "one 1, two 3s", or: `1123`. Two properties of this process are: if you start with only 1s, 2s and 3s (in ranges no longer than 3) you will never get other numbers; and if you keep applying the rule the list will grow longer and longer. The question the puzzle asks is: exactly how long is the sequence after applying the rule 40 or 50 times?

You are told exactly what to do and the rule itself seems simple enough, so the challenge of this puzzle lies in the implementation. Here's how I did it in Python:

    def looksay(a, b, len):
        i = k = 0
        while i < len:
            j = i + 1
            while j < len and a[j] == a[i]:
                j += 1
            b[k] = j - i
            b[k + 1] = a[i]
            k += 2
            i = j
        return k  # new length of b

where `a` and `b` are pre-allocated arrays to avoid dynamic appending, `a` is the original, `b` is the next step, and they switch for each next step. Indexes `i` and `j` indicate a range of the same number in `a`, index `k` is the current location in `b`. So it's a very literal translation of the look-and-say algorithm. This worked fine! It takes about a second to calculate the whole sequence after 50 steps. I'm sure there are ways to speed up the Python version, I'm certainly no expert on that. The compiled version in C took about 5 milliseconds on modern hardware, using an internal timer.

So Eric was kind enough, it was only day 10 after all, to choose a number of steps for part 2 where the naive approach still works. It takes some time but nothing too bad. John Conway proved that, in the limit, there is a specific, fixed growth factor of the length between two steps which is about 1.3, now known as [Conway's Constant](https://www.wolframalpha.com/input/?i=conway%27s+constant). So the length of the sequence grows exponentially. The algorithm presented above is directly proportional to that length, so the time needed for each step also grows exponentially. Not ideal! As an indication, the space needed after 50 steps was about 4 MB but after 100 steps it would be about 3 TB. Can't afford that with current SSD prices...

One of Conway's insights about the look-and-say sequence was that there is only a limited number of combinations that occur again and again. These are the "atomic elements" in the table linked above. When such an element appears in the sequence, it evolves according to a fixed pattern and it does not interact with the rest of the sequence. AS LUCK WOULD HAVE IT, our input is precisely one such element. The table lists exactly what the next step is for each element. They call this *decay*, another atomic analogy. A lot of elements decay to one other element, some to more than one, the most is six for Ga -> Eu,Ca,Ac,H,Ca,Zn.

Because we only have to deal with elements, and because elements don't interact with each other, the order we keep them in does not matter. In fact, and this is the big trick, we only need to keep track of how many we have of each element. Now the hardest and most time-consuming part is to translate the element decay table from the Wikipedia page into a data structure we can use efficiently. In a language with built-in hash tables or dictionaries, this could be done like so:

    decay['Li'] = ['He']
    decay['Be'] = ['Ge', 'Ca', 'Li']

and 90 more entries for all the other elements. It took a little more effort in bare-bones C where, after some sorting and searching, I replaced every element name with its direct array index. After that, the function that does all the work for one step is now, in C:

    // Decay elements from a to b, one step to generate the next sequence
    // 'restrict' = must be non-overlapping arrays
    static void onestep(const int64_t *restrict a, int64_t *restrict b)
    {
        memset(b, 0, sizeof *b * ELEMENTS);  // reset b
        for (int i = 0; i < ELEMENTS; ++i)
            for (int j = 0; j < split[i]; ++j)
                b[decay[i][j]] += a[i];
    }

where `split[i]` is the decay count of element `i`, e.g. 3 for "Be", and `decay[i][j]` is the element index of the j'th decay element of element `i`. For example, the same entry for Be like above is, iffff C could do array assignments:

    // Be -> Ge,Ca,Li
    decay[3][] = {31, 19, 2};

Int64 arrays `a` and `b` hold the element counts of the current and the next step. For the puzzle with 50 steps, int32 would be enough, but we're going further than that. There are 92 elements so the array length of `a` and `b` is always 92. This means that every step of the sequence generation takes a fixed amount of time, and the space needed does not grow at all! Well, until the counts overflow, but that doesn't happen for int32 in 50 steps. And for int64 it doesn't even happen in 150 steps. For my input, element Po of size 10, the final sequence length after 150 steps is 1,168,021,999,835,586,648 or about 1x10^18 = 1000^6 which is one [exabyte](https://en.wikipedia.org/wiki/Byte#Multiple-byte_units) or one million terabyte. With the naive or brute-force algorithm, that would be slightly too large to store on my computer.

The whole program of three parts with up to 150 decay steps, calculating a sequence length of one exabyte, now takes only 17 microseconds on modern hardware, or 43 microseconds on a Raspberry Pi 5. This is with an internal timer, does not include reading the table of elements from disk, does include making the hash table (= sort names, look up names, replace with indexes).

* [Old version in Python](https://github.com/ednl/adventofcode/blob/main/2015/10.py)
* [New version in C](https://github.com/ednl/adventofcode/blob/main/2015/10.c)
* [Elements table from Wikipedia](https://github.com/ednl/adventofcode/blob/main/2015/10.txt)
* [This post](https://github.com/ednl/adventofcode/blob/main/2015/10.md)
